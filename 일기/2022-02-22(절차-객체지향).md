## asset bundle 이란?
asset bundle의 개념: https://young-94.tistory.com/11
addressable asset system: https://young-94.tistory.com/47

## 절차 / 객체 지향의 특징 그리고 차이점
절차지향은 데이터를 중심으로 함수를 구현합니다. 이에 반해 객체지향은 기능을 중심으로 메서드를 구현하게 됩니다.

절차지향은 프로그램 설계시 아래부터 위로 돌탑을 쌓듯이 무조건 순서에 따라서 프로그램이 진행되도록 설계된다.
즉, 쌓은 돌탑 중간에 결함이 생기거나 빠지면 탑이 무너지듯이 프로그램 또한 진행 순서 중간에 결함이 생기면
코드 전체에 영향을 주게 된다.

객체지향은 결함이 생겨도 프로그램이 모듈화되어있기때문에 중간에 문제가 생기면 해당 모듈만
고쳐서 해결이 가능하다.
객체지향의 특징은 세가지, 다형성 - 상속 - 캡슐화
상속을 통해서 코드의 재사용율을 높이고
캡슐화를 통해 보안성을 높이고
다형성을 통해 코드의 유연성을 높일 수 있다.

static method는 interface를 사용하여 오버라이딩이 불가능하다는 점은 객체지향적 관점에서 코드의 재사용율을 떨어뜨리는 것으로 볼 수 있다.
static 객체는 외부에서도 영향을 주기때문에 문제가 발생했을때 프로그램의 흐름을 추적하기 어려워지고 코드가 얽힐 수 있기때문에 static 키워드는
절차지향적이지 않고 적대시하는 것이다.


손을 흔드는 동작을 절차 / 객체 지향적 관점에서 설계를 한다면
절차는 (팔꿈치 관절 각도 -= 각도;  손목 관절 각도 -= 각도;) 처럼 데이터를 중심으로 구성한다.
객체는 {팔꿈치 회전(), 손목 관절 회전()} 동작(기능)을 중심으로 메서드를 구현한다.

참조: https://sc.greenart.co.kr/community/greenDesignNews_view?idx=1679
참조 2: https://unabated.tistory.com/m/entry/%EC%99%9C-%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-static%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%A7%80%EC%96%91%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80



## dependencies in programming
프로그램 A를 개발 또는 실행할때 프로그램 B가 반드시 필요한 경우 이 B를 dependencies라고 한다. 즉, 의존한다는 의미이다.
실질적인 예로, Enemy 오브젝트에 Pathfinding 기능을 추가할때 A* 라이브러리를 사용하는 것도 위의 경우에 해당한다.
하지만 dependency를 사용하는데 있어서 주의해야할 점이 존재한다.
예를 들면 버전 관리에 있어서도 해당이 되는데, 만약 개발환경의 unity 버전이 유저의 unity 버전보다 높을 경우 상위 버전의
기능이 하위 버전에 포함되어있지 않을 수 있기때문에 dependency의 위험성이 존재할 수 있다.
또한 프리팹 A가 프리팹 B를 참조하여 사용할때 프리팹 B는 dependency가 된다.

## 동기 비동기
https://koras02.tistory.com/87

동기: 요청시 결과를 내기전까지는 아무런 동작을 수행할 수 없음(= 요청과 결과가 동시에 일어나야함, 프로그램의 처리는 매우 빠르므로
요청과 동시에 처리 결과가 바로 산출이되므로 이러한 맥락에서 동시에 일어난다고 얘기하는듯)   
비동기: 요청 후 결과를 내기전까지 다른 동작을 수행할 수 있다. 
ex) 
invoke(func, 4)의 경우 해당 함수를 4초후에 실행하라는 의미인데,
invoke를 명령한 후 대기시간 4초동안 어떠한 작업을 한다면 그건 비동기 작업을 한 것이다.
프로그램을 다운받으면서 게임을 진행하는 것도 비동기라 볼 수 있음
멀티태스킹과 관련이 많이 되어있는듯

동기의 장점: 설계가 단순해짐
동기의 단점: 결과가 나타나기전까지 아무런 행동을 할 수 없으므로 자원 효율이 떨어진다.

비동기의 장점: 자원 효율이 증가한다.
비동기의 단점: 설계가 복잡해짐(프로그램의 진행 순서가 왔다갔다하기때문에)

## interface

interface로 선언한 클래스의 멤버는 변수의 경우 final, 메소드는 abstract로 밖에 선언되지않음

1. 다중상속의 문제점은 두 부모 클래스의 메소드가 동일한 이름일때 자식 클래스에서 호출할 메소드가 모호해질때 문제가 발생
interface는 다중상속의 문제 해결 가능, 단 이 문제해결의 키포인트는 두 부모클래스를 인터페이스로 선언하면
두 부모클래스의 메소드가 추상 메소드가 되므로 두 인터페이스를 상속받았을때 중복된 메소드를 받아도 정의되지않은 추상 메소드를 상속받으므로
충돌이 발생하지않는다는 점이다.

2. 일종의 가이드라인이 제시되므로 표준화된 구현가능





