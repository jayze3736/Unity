# 세그먼트 기법
code, stack, data 의 의미단위로 분할하기에 효과적이다.(장점)

- 논리적 공간(virtual memory)를 의미단위로 분할한다. code, data, stack 단위로 분할할 수 있다.
- 함수 단위를 의미 단위의 예로 들수 있고 사용자가 어떤 의미로 분할하느냐에 따라 세그먼트의 의미와 크기가 달라진다. 
- 의미 단위로 분할하기때문에 페이지처럼 ***크기가 일정하지않다.***
- 페이지 테이블의 경우 보통 1M개의 엔트리를 생성해야될때도 있었지만 세그먼트 테이블의 엔트리는 1M개에 비해서 작은 개수의 엔트리를 가진다.

## 레지스터 및 테이블 엔트리 값
- STBR, STLR 레지스터는 주소변환을 도와준다.   
- STBR은 세그먼트 테이블 베이스 레지스터이며 세그먼트 테이블을 찾는 레지스터이다.    
- STLR은 세그먼트 테이블 렝스 레지스터이며 세그먼트의 개수를 의미한다.  
- 주소 변환에 필요한 논리 주소 값은 s, d이다. s는 세그먼트 테이블의 인덱스를 의미하며 STLR에서 나타내는 세그먼트 개수를 넘을 수 없다. d는 오프셋에 해당한다.

## 세그멘트 특징
- 페이징 기법에서는 페이지 크기와 프레임 크기가 같기때문에 페이지 번호와 오프셋값으로 물리적 메모리에 접근이 가능했다. 이에 비해, 세그먼트 기법은 크기가 세그먼트 별로 다르기때문에 페이징과 같은 방법으로 주소 변환을 하면 안된다. 
- MMU를 이용하여 base register로 물리 메모리에서의 시작주소, limit register로 프로그램의 크기를 정했듯이 세그먼트도 엔트리 값에 base 값으로 세그먼트의 시작 주소를 나타내고 limit 값을 두어 세그먼트의 크기 또는 d값의 범위를 지정한다. 
- s로 세그먼트 테이블의 s번째 엔트리에 접근하고 해당 세그먼트의 시작 주소 값인 base에서 d만큼 떨어진 곳의 주소를 반환한다. 
- 세그먼트별로 크기가 다르기때문에 d값의 범위 또한 다르다.


## 장점/단점
### 장점
의미 단위로 수행하기가 효과적이다. -> 공유 보안기능에서 장점을 가진다.
#### 1. Protection bit
페이징의 경우 하나의 페이지에 code 또는 data 영역이 겹치는 영역을 가질 수 있고 이런 경우 protection bit을 설정하기가 어렵다.   
그러나 세그먼트의 경우 의미단위로 나누기때문에 겹치는 부분이 발생할 수 없기때문에 protection bit을 설정하기 쉽다.   
protection bit은 read/write/read-only와 같은 접근 권한을 설정하는 비트를 의미한다.
#### 2. Shared segment
페이징에서 Shared code의 경우 code 영역에 대한 페이지를 공유할때 페이지내에 code영역과 data 영역이 겹치는 부분이 발생할 수 있는데 이러한 경우에 공유하기가 어려울 수 있다. 
그러나 세그먼트의 경우 의미단위로 나누기때문에 겹치는 부분없으므로 공유할 세그먼트를 올리기에 수월하다.  
#### 3. 페이지 테이블 보다 메모리 낭비가 적음
페이징에 비해 세그먼트는 개수가 비교적 적기때문에 생성해야하는 세그먼트 테이블 엔트리 수도 페이지 엔트리보다 적기때문에 메모리에 올려야되는 세그먼트 테이블이 페이지 테이블보다 공간 낭비가 덜하다.  


### 단점 
크기가 일정하지않기때문에 홀과 같은 외부조각문제가 발생할 수 있다. 따라서 best fit과 first fit 알고리즘을 사용하여 메모리 할당 대책을 사용한다.



# 2. 세그먼트 + 페이징
세그먼트 처럼 프로그램의 논리 주소 공간을 의미단위(세그먼트)로 나누고 메모리에 올릴때는 페이지 단위로 올려서 세그먼트의 외부조각 문제를 해결하고 의미단위로 논리 주소 공간에서 작업한다.  

## 특징
- 논리주소인 세그먼트 번호 s와 오프셋 d로 접근한다. 오프셋 d는 세그먼트 한개에서 접근가능한 위치를 의미한다.  
- s값으로 세그먼트 테이블에서 엔트리를 찾고 해당 엔트리는 segment length와 page-table base 값을 반환한다.  
- 오프셋 d는 segment length를 넘을 수 없으며 넘을 경우 오류로 처리한다. 세그먼트의 시작 주소인 page - table base값을 반환한다. 즉, 세그먼트 내의 페이지 테이블의 시작 주소를 반환하는 것이랑 동일하다.
- 오프셋 d는 다시 두개의 의미단위로 분리되는데, 페이지 번호 p와 오프셋 D로 분리된다. 세그먼트 내에 페이지 테이블이 존재하기때문에 세그먼트에서 얼만큼 떨어져있는지를 나타내는 d는 페이지 테이블에서 페이지 번호인 p 그리고 그 페이지에서 얼만큼 떨어져있는지 나타내는 D로 분리가 될 수 있다.
- 페이지 테이블의 시작 위치 그리고 페이지 번호로부터 페이지 테이블에서 프레임 값을 알아내고 그 프레임 번호에서 `d 만큼 떨어진 곳의 주소를 반환한다.
- 세그먼트 하나가 페이지 테이블로 구성된다. 

## 장점
장점: 논리 주소 공간은 의미단위로 나누고(세그먼트의 장점) 메모리에 올릴땐 페이지 단위로 올리기때문에 외부 조각 문제 발생하지않음(페이징의 장점)

## Note
헷갈릴 만한 점: 1차의 세그먼트 테이블의 엔트리 중 segment length는 STLR가 아니라, limit값과 동일하다.  
다시 말해서, STLR은 세그먼트의 개수를 나타내고 segment length는 한 세그먼트의 길이 또는 크기를 의미한다.   
page-table base는 n번째 세그먼트의 시작위치이다. 즉, n번째 세그먼트가 보유하는 페이지 테이블의 시작위치를 말한다.



