# 프로세스
프로세스는 현재 실행중인 프로그램을 의미한다.

## 메모리
메모리는 기본적으로 code - data - stack - heap 영역으로 구성된다.

## code - data - stack - heap
1. code 영역: 실행할 명령어가 보관됨
2. data 영역: 변수가 보관됨(지역, 전역 변수)
3. stack 영역: 함수 호출 정보가 보관됨
4. heap 영역: 사용자가 할당하는 메모리 공간

### virtual memory
virtual memory는 프로세스가 사용할 code, data, stack 주소 공간을 의미한다. 이때, 이 세가지 영역의 모든 주소값이 메모리에 그대로 올라가지않고 필요한 데이터값만
메모리에 올려서 사용한다.

### 커널 주소 공간
OS 또한 프로세스이므로 커널 프로세스라고도 불리는데, 커널 프로세스도 사용할 code - data - stack 주소 공간을 보유한다.
1. code: 효율적인 작업을 위한 명령어가 저장됨
2. data: PCB, CPU의 작업 큐, Device 큐 등 필요한 자료구조를 저장한다.
3. stack: 프로세스에서 시스템 콜이 발생했을때 커널 함수호출 정보를 저장한다. 즉, 커널 스택이 쌓인다. 커널 주소공간은 여러 프로세스들이 시스템 콜을 통해 주소 공간을 간접적으로 공유하여 커널 함수를 실행하기때문에 프로세스마다 별도로 커널 스택이 존재한다.

## CPU 수행정보 관련 하드웨어
PC(Program Counter), Register가 존재하며 이들은 CPU가 작업할때 필요한 하드웨어에 해당한다.

### PC(Program Counter)
CPU가 현재 처리하고 있는 메모리 공간의 명령어의 주소를 가리킨다.

### register
CPU의 기억 공간에 해당한다. 외부로부터 값을 복사하여 저장하고 CPU에서 연산처리를 한다던지 임시적으로 데이터값을 담아둘때 사용하는 공간이다.

## 프로세스 문맥(Process Context)
CPU는 여러 프로그램간을 이동해가며 명령어를 처리하는데, 이때 처음 실행했던 프로세스에서 CPU의 프로세스간의 이동을 거쳐 다시 동일한 프로세스로 돌아왔을때 
처음 어디까지 명령어를 처리했는지 파악하기위해서 진행상황을 기록할필요가 있다.   
이때 프로세스의 처리 진행 상황을 프로세스 문맥이라고 한다.

+ PC가 어디를 가리키고 register에는 어떤 값이 저장되어있는지
+ 메모리 주소 공간(code data stack)에는 어떤 값이 저장되어있는지
+ 커널 주소 공간에는 어떤 값이 저장되어있는지

이러한 상황을 종합적으로 프로세스 문맥이라고 부른다.


## PCB(Process Control Block)
프로세스 문맥을 기록하기 위한 자료구조이다. PCB에는 다음과 같은 값들이 저장된다.

### OS가 관리상 사용하는 정보
1. process number: process에 접근하기위한 고유의 ID 정보
2. pointer: 프로세스가 queue에 대기할때 순번을 정하기위해 다음 프로세스를 가리키기 위한 포인터
3. process state: 현재 프로세스의 상태

### CPU 수행 관련 하드웨어
1. PC의 주소값: PC가 가리키던 주소값
2. register: CPU가 작업을 수행하기위해 어떤 값을 저장하고있었는지에 대한 값

### 메모리 관련 값
프로세스에서 사용하고있는 code, data, stack 영역의 주소값

### 파일 관련값


## 문맥 전환(Context Switching)
프로세스 A에서 시스템 콜이 발생하여 OS에게 커널함수 실행을 요청할 경우, I/O 작업과 같은 오래걸리는 작업은 I/O 요청이후 다음 프로세스에게 CPU를 넘겨준다. 이때,
실행중인 프로세스가 A에서 B로 넘어가기때문에 프로세스 A의 현재 PCB를 커널 주소 공간에 저장하고 B의 PCB를 읽어와야한다. 이러한 문맥 전환은 오버헤드가 크기때문에 매우 조심스러운 개념이다.

그러나 주의해야할 점은 시스템 콜이 발생했다고 해서 무조건 문맥 전환이 발생하는 것은 아니다. 모든 시스템 콜이 I/O 작업 처리 요청은 아니기때문이다. 다시 말해서
시스템 콜을 실행할 시, 만약 I/O 요청이 아닌 다른 커널 함수를 실행했을때 프로세스가 변경되지않고 유지된 상태로 다음 명령어를 수행할 수도있기때문이다.

## State
프로그램의 현재 진행상태를 의미한다.
### ready
프로세스가 현재 메모리에 올라와있고 CPU를 받으면 프로세스 실행이 가능한 상태
### running
현재 프로세스가 CPU를 받아서 실행중인 상태
### blocked
현재 프로세스가 I/O 요청 또는 시스템 콜처럼 외부에서의 처리를 대기하여 CPU를 받아도 작업하지 못하는 상태
### suspended
프로세스가 외부의 이유로 인해 메모리를 사용하지못하고 디스크로 쫒겨나서 CPU를 받아도 작업하지 못하는 상태  
여기서 외부의 이유는 예를 들면 다음과 같다.  
1. 중기 스케쥴러에의해 메모리 부족으로인한 디스크로의 추방
2. 사용자의 break key로 인한 프로그램 중단 및 디스크로의 추방

suspended 상태에서는 외부에서 resume해줘야 프로세스가 suspended 상태에서 벗어날 수 있다.   
suspended상태는 suspended ready와 suspended blocked가 존재하며 전자의 경우는 ready상태에서 디스크로 쫒겨난 경우,   
후자는 I/O 요청을 하고 blocked 상태에서 대기하다가 디스크에서 쫓겨난 경우에 해당한다.   
suspended blocked에서 이벤트가 완료되면 suspended ready로 상태전환이가능하다.

## job queue
job queue는 ready queue와 device queue의 집합을 의미한다. 

### ready queue
프로세스가 메모리에 적재되는것은 ready queue라는 큐에 프로세스가 추가되는 것으로 볼 수 있다. ready queue에 ready 프로세스가 dequeue되어 running 상태가 된다.
커널 주소 공간에서 메모리에서 사용할 자료구조는 ready queue에 해당한다.

### device queue
running 중인 프로세스가 I/O 요청을 할때 요청한 I/O device의 queue에 프로세스가 추가된다. 이 I/O device 별로 존재하는 queue를 device queue라고 한다.


## Scheduler
### long term scheduler(장기 스케쥴러)
실행예정인 프로세스를 ready 큐에 넣을지 결정하는 스케쥴러이다.즉, 메모리를 줄지 말지 결정하는 스케쥴러이다. 

### medium term scheduler(중기 스케쥴러, 메모리 스케쥴러)
일단 실행할 프로세스에게 모두 메모리를 주고 메모리 공간이 부족해지면 스케쥴러의 지침에 따라 디스크로 추방하여 메모리 공간을 확보한다.

### shorts term scheduler(단기 스케쥴러, CPU 스케쥴러)
어느 프로세스에게 CPU를 줄지 결정하는 스케쥴러이다. 메모리에 프로세스가 적재되면 주소 순번대로 프로세스가 CPU를 사용하는 것이아니라 효율이 가장 높은 쪽으로
CPU를 프로세스에게 넘긴다.





