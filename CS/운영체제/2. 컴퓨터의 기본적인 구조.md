# 컴퓨터의 기본적인 구조
수업 참조: http://www.kocw.net/home/search/kemView.do?kemId=1046323   
컴퓨터는 기본적으로 CPU와 메모리로 구성되어있다. CPU와 메모리이외에도 자원(메모리)을 효율적으로 사용할 수 있도록 TIMER, 레지스터, mode bit 등 여러 하드웨어가 존재한다.

## 1. CPU
CPU는 컴퓨터에서 연산처리 역할을 수행하며 주로 메모리와 작업한다. 
CPU에는 interrupt, mode bit, register 장치를 포함한다. 이러한 장치들은 커널이 특정 작업을 수행할 수 있도록 도와준다.   
CPU는 여러개의 사용자 프로그램에 대한 인스트럭션(instruction)을 가져와서 처리한다. 이때 CPU는 프로그램별로 처리해야할 인스트럭션이 존재하는지 확인하고 여러 프로그램을 이동해가며
인스트럭션을 처리한다. 따라서 시분할의 개념은 CPU가 매우 짧은 시간간격으로 복수의 프로그램 처리하는 것을 나타낸다.

### 커널
커널은 운영체제(OS) 프로그램이 메모리에 올라와있는 것을 말한다. 사용자 프로그램에선 보안상의 목적으로 요청할 수 있는 명령어가 제한되어있다. 대신 사용자 프로그램에서
커널함수 호출을 OS에게 부탁하여 I/O controller에 명령을 내리는등의 작업을 수행할 수 있다. 
사용자 프로그램에서 다른 프로그램의 메모리 주소를 확인한다던지, 디스크에 저장된 파일을 직접 읽어온다던지 등의 작업은 해킹과 같은 취약점이 존재하기때문에
이러한 작업은 보안상 OS가 커널함수로 처리한다.

### interrupt(인터럽트)
커널 함수 호출과 같은 OS 프로그램 작업을 실행하기위해 CPU의 점유를 사용자 프로그램에서 OS 프로그램으로 전환하기 위한 CPU의 장치이다.   
메모리에서는 사용자 프로그램과 운영체제 프로그램이 적재되어 처리된다. 다음과 같은 경우에 인터럽트 처리가 이루어진다.

1. 요청한 I/O 작업이 완료되면 인터럽트가 활성화된다. 
2. TIMER에 의해 프로그램에서 정의된 시간이 지나면 인터럽트가 활성화된다. (하드웨어 인터럽트)
3. 사용자 프로그램에서 I/O 작업을 요청할때 인터럽트를 활성화시키고 OS 프로그램에게 커널함수 실행을 요청한다.(System Call - 소프트웨어 인터럽트)
4. 프로그램에서 오류가 발생했을 경우 인터럽트를 활성화시킨다.(Exception - 소프트웨어 )

인터럽트가 활성화되면 어느 프로그램에서 CPU를 점유하고있든지 CPU의 작업 권한을 OS 프로그램에게 넘겨주게된다.

### register
CPU에서 데이터를 저장할 수 있는 작은 기억공간

### mode bit
CPU가 사용자 프로그램을 처리하고 있으면 mode bit은 0, OS 프로그램을 처리하고 있으면 mode bit은 1을 표시한다.
mode bit이 0일때는 사용자 모드(User mode), 1일때는 커널 모드(Kernel mode)라고 한다. 

## 2. 메모리
메모리에 사용자 프로그램과 OS 프로그램이 적재되어 실행된다. CPU는 메모리에 접근하여 사용자 프로그램을 작업하고 그 프로그램이 종료될때 운영체제 프로그램을 실행한다.
### Memory Controller
CPU의 메모리 접근과 DMA의 메모리 접근간의 충돌이 발생하지않도록 정리하는 역할을 수행한다. 예를 들면, CPU와 DMA가 메모리의 같은 주소를 참조하지않도록 방지하는 경우가 해당한다.
### 사용자 프로그램
말 그대로 사용자가 작성한 프로그램에 해당한다. 프로그램이 종료되면 인터럽트가 활성화되어있는지 확인하고 활성화되어있으면 OS 프로그램에게 CPU 점유를 넘기고 그렇지 않을 경우, 
다음 주소의 사용자 프로그램에게 CPU 점유를 넘긴다.
### OS 프로그램
보안상 사용자 프로그램에서 실행할 수 없는 명령어를 처리하기 위해 실행하는 프로그램이다. OS 프로그램 또한 명령어를 수행하고 나면 인터럽트가 활성화되어있는지 확인한다.


## 3. Timer
어느 사용자 프로그램이 CPU의 작업시간을 독점하지않게 방지하기위해 프로그램에 TIMER 값을 설정한다. 설정한 타이머값만큼 시간이 지나면 즉시 해당 프로그램의 CPU 점유를 멈추고
인터럽트가 활성화된다.   
예를 들면, 무한 루프와 같은 끝나지 않는 작업은 CPU를 독점하게되므로 시간제한이 없다면 그 사용자프로그램은 CPU를 독점하는 셈이 된다. 독점하게되면 다른 작업을 수행할 수 없고
완전히 시스템이 멈춰버리는 현상이 발생하므로 이러한 경우를 방지하기위해 TIMER 값을 두어 프로그램에 시간제한을 두는 것이다.

## 4. DMA(Direct Memory Access)
I/O 작업이 완료될때마다 인터럽트를 걸면 CPU는 하던 작업을 그만두고 OS 프로그램을 사용하여 필요한 I/O 데이터값을 가져온다. 그 이후 해당 데이터를 사용자프로그램에 복사시키는데,
이렇게되면 빈번히 인터럽트가 걸려 시스템 효율성이 떨어진다.    
따라서 I/O 작업을 수행할때 CPU의 개입이 없도록 I/O 결과 데이터를 DMA에서 직접 메모리에 복사시킨다.    
즉, I/O와 메모리간의 직접적인 데이터 전송이 가능해지므로 바이트마다 인터럽트를 발생시켜 값을 복사-저장할 필요없이 블록단위로 인터럽트를 발생시키면 된다.   
여기서 블록단위로 인터럽트를 발생시킨다는 점이 헷갈릴만한데, 요점은 바이트 -> 블록 단위로 인터럽트를 발생시키고 이는 단위가 증가했기때문에 발생시켜야되는 인터럽트 횟수가
줄었다고 보면 된다.

## 5. I/O (Input/Output)
I/O는 마우스(입력 장치), 스피커(출력 장치)와 같은 입력/출력 장치를 말한다.
### I/O Controller
마우스면 마우스 컨트롤러, 스피커면 스피커 컨트롤러, 디스크면 디스크 컨트롤러 각각 I/O 장치별로 Controller가 존재하며 사용자 프로그램에서 I/O에 관련된 명령을 처리해야할 경우
CPU가 I/O 컨트롤러에게 명령을 내리고 컨트롤러에서 해당 명령을 처리한다.    
작업이 완료되면 인터럽트를 활성화시키고 OS 프로그램에서 이 값을 가져가라고 한다.
그러나 이렇게 여러 I/O 작업에 의해 인터럽트가 빈번히 활성화되고 CPU의 점유가 OS 프로그램에게 자주 넘겨지면 효율적으로 시스템이 돌아가지않을 수 있다. 따라서 DMA라는 장치는 
효율적으로 I/O 처리를 도와준다.

### buffer(버퍼)
I/O 컨트롤러의 저장공간에 해당하며 버퍼로 I/O 데이터값을 저장하고 처리한다. 예를 들면 키보드에서 문자를 입력하면 버퍼로 문자가 저장되고 문자열 입력이 끝나면 해당 버퍼에 저장된
문자열 값을 추출하여 컨트롤러에게 넘기고 OS는 이 값을 메모리에 복사하여 처리한다.

### 동기식/비동기식 I/O
#### 동기식 I/O
1. 방식 1: I/O 요청후에 I/O 처리가 완료될때까지 CPU를 사용하지않는 방식
2. 방식 2: I/O 요청후에 I/O 처리가 완료될때까지 CPU를 다른 프로세스에게 넘겨주고 명령어를 실행하는 방식(우리가 현재 언급하는 I/O 처리 방식)
#### 비동기식 I/O
I/O 요청후에 I/O 처리를 기다리지않고 요청한 프로세스의 명령어를 수행할 수 있는 방식   
동기식 I/O의 방식 2와 비교하면 방식 2는 프로세스가 I/O 요청을하면 그 프로세스의 명령어는 수행하지못하는데 비해 비동기식 I/O는 수행할 수 있다.


## 6. 기타
### 장치 드라이버
장치 드라이버에는 OS 코드에서 Controller에 명령하기 위한 명령어가 정의되어있다. 

### 펌웨어
I/O Controller에서 해당 I/O 장치의 작업을 위한 명령어가 정의되어있다.

### ISR(Interrupt Service Routine)
I/O 작업이 완료되었을때 인터럽트가 활성화되는데, 이때 활성화된 인터럽트를 체크했을때 어떤 명령어를 수행해야되는지 정의되어있다. 예를 들면, 디스크에서 파일을 읽어오는 경우
블록 단위로 파일을 가져온 후 해당 파일을 화면에 출력하거나 아니면 하지않는등 I/O 작업시 어떤 작업을 해야하는지가 정의되어있는 것이 ISR이다.

### Interrupt Vector
인터럽트 벡터는 어떤 I/O 장치의 인터럽트가 발생했을때 처리해야할 ISR을 바로 찾을 수 있도록 주소를 가리키는 값이다.   
예를 들어 3번 인터럽트가 발생 -> 인터럽트 벡터가 코드 영역에 저장된 ISR 주소를 참조 -> 커널 함수 실행
