# 고전적인 프로세스 동기화 문제

## 1. Producer - Consumer 문제(생산자 - 소비자 문제)
![Pd-Cs problem](https://user-images.githubusercontent.com/79313194/165043417-c34d53f7-500d-407a-a412-3106a5642902.png)


### Producer - Consumer 역할
Producer: 빈 버퍼(empty buffer)에 데이터를 채워놓는 프로세스
Consumer: 채워진 버퍼(full buffer)에 데이터를 제거하고 이를 다른곳에 복사하거나 사용하는 프로세스이다.
Producer와 Consumer는 각각 포인터를 가지고 버퍼에 작업을 한다.

### Buffer란?
컴퓨터에서 사용하는 임시 저장공간을 의미하고 큐의 일종이다. 마구잡이 입력된 데이터를 입력된 순서대로 저장하고 사용해야할 때는 가장 늦게 들어온 값을 추출하여 사용한다.(LIFO 구조) 

### 조건
#### - Semaphore -
mutex: 버퍼에 대한 race condition을 방지하기위한 binary semaphore   
full, empty: 찬 버퍼, 빈 버퍼의 개수를 확인하기 위한 counting semaphore

#### - 공유 변수 -
buffer: 버퍼


### 문제
1. Producer 입장에서는 empty buffer가 없으면 작업을 하지못하고 Consumer 입장에서는 full buffer가 없으면 작업을 하지못한다.
2. Producer - Producer, Consumer - Consumer 끼리는 동일한 버퍼에 접근해서는 안된다.(Race Condition이 발생하면 안됨)


### 코드
Producer
```C
do{

...
P(empty)  //Producer 입장에서는 빈 버퍼를 획득해야함, 빈 버퍼가 없을 경우 대기
P(mutex) //버퍼 전체에 lock을 걸고 접근
...
add data x to empty buffer
...
V(mutex)
V(empty)
...

}
while(1)

```

Consumer
```C
do{

...
P(full)  //Consumer 입장에서는 차있는 버퍼를 획득해야함, 차있는 버퍼가 없을 경우 대기
P(mutex) //버퍼 전체에 lock을 걸고 접근
...
remove data x from empty buffer
...
V(mutex)
V(full)
...

}
while(1)



```

### 의문점
처음에 buffer가 큐인줄 모르고 일반 배열인줄 알았다. 그래서 만약 프로세스가 접근할때 mutex값이 아니라 mutex의 배열을 사용하여 락을 걸때 버퍼 전체를 걸지않고
접근하려는 버퍼만 걸 줄 알았다.    
mutex를 이용하여 하나의 프로세스가 접근할때 버퍼 전체를 락을 건다는 건 buffer가 큐이고 순차적으로 하나 하나씩 데이터가 빠져나가기때문인것 같다.


## 2. Reader - Writer 문제

### Reader - Writer 역할
Reader: 공유데이터를 읽는 프로세스, 이때 공유데이터를 읽기만하고 값을 변경하지않기때문에 동일한 공유데이터에 여러개의 Reader 프로세스의 접근은 허용한다.   
Writer: 공유데이터를 쓰는 프로세스, 공유데이터를 쓰기때문에 Race condition 문제가 발생할 수 있다.

### 특징
Reader 끼리는 동일한 파일을 읽어들이는 것을 허용하기때문에 lock을 걸때 신경을 써줘야한다.

### 조건
#### - Semaphore -
db: 공유데이터에 lock을 걸기위한 binary semaphore
mutex: readcount에 lock을 걸기위한 binary semaphore 

#### - 공유 변수 -
readcount: 현재 몇명의 reader들이 공유데이터를 읽고있는지 파악하기위한 정수형 변수
DB: 공유 데이터

### 문제
1. reader와 writer가 DB에 접근할때 lock을 걸고 접근해야한다.
2. reader 사이에선 race condition이 발생하지않으므로 특별한 조건을 걸어 reader 끼리는 공유 데이터를 읽게 해준다.


### 코드
Writer
```C
do{
P(db)
...
Write DB
...
V(db)

}
while(1)

```
Reader
```C
do{
P(mutex)
++readcount;
if(readcount == 1)  //writer는 막고 reader는 통과
P(db);
V(mutex)
...
Read DB
...
P(mutex)
--readcount;
if(readcount == 0)
V(db);
V(mutex)
}
while(1)
```

### 설명
Reader에서 readcount가 1이면 db에 lock을 건다. 이때 또다른 reader에서 코드를 실행하게되면 readcount값은 2가되므로 db를 획득하지않고 critical section에 진입할 수 있다.   
반면 Reader측에서 db에 lock을 건 상황에서 writer의 코드를 실행하면 P(db)연산에서 대기하게된다.    
또한 N개의 Reader 프로세스가 공유데이터에 접근하고있을때 readcount가 0이 될때까지는 db를 반납하지않으므로 N개의 reader 프로세스가 모두 읽고 나와야지 writer가 db를 읽을
수 있다.


### 문제점
Starvation: reader가 계속 들어와서 공유데이터를 읽으려고하면 writer는 모든 reader가 읽을때까지 접근하지못하므로 writer는 오랜시간동안 데이터 접근이 불가능할 수 있다.

## 3. Dining Philosophier(밥먹는 철학자)
