# 고전적인 프로세스 동기화 문제

## 1. Producer - Consumer 문제(생산자 - 소비자 문제)
![Pd-Cs problem](https://user-images.githubusercontent.com/79313194/165043417-c34d53f7-500d-407a-a412-3106a5642902.png)


### Producer - Consumer 역할
Producer: 빈 버퍼(empty buffer)에 데이터를 채워놓는 프로세스
Consumer: 채워진 버퍼(full buffer)에 데이터를 제거하고 이를 다른곳에 복사하거나 사용하는 프로세스이다.
Producer와 Consumer는 각각 포인터를 가지고 버퍼에 작업을 한다.

### Buffer란?
컴퓨터에서 사용하는 임시 저장공간을 의미하고 큐의 일종이다. 마구잡이 입력된 데이터를 입력된 순서대로 저장하고 사용해야할 때는 가장 늦게 들어온 값을 추출하여 사용한다.(LIFO 구조) 

### 조건
mutex: 버퍼에 대한 race condition을 방지하기위한 binary semaphore
full, empty: 찬 버퍼, 빈 버퍼의 개수를 확인하기 위한 counting semaphore

### 문제
1. Producer 입장에서는 empty buffer가 없으면 작업을 하지못하고 Consumer 입장에서는 full buffer가 없으면 작업을 하지못한다.
2. Producer - Producer, Consumer - Consumer 끼리는 동일한 버퍼에 접근해서는 안된다.(Race Condition이 발생하면 안됨)


### 코드
Producer
```C
do{

...
P(empty)  //Producer 입장에서는 빈 버퍼를 획득해야함, 빈 버퍼가 없을 경우 대기
P(mutex) //버퍼에 lock을 걸고 접근
...
add data x to empty buffer
...
V(mutex)
V(empty)
...

}
while(1)

```

Consumer
```C
do{

...
P(full)  //Consumer 입장에서는 차있는 버퍼를 획득해야함, 차있는 버퍼가 없을 경우 대기
P(mutex) //버퍼에 lock을 걸고 접근
...
remove data x from empty buffer
...
V(mutex)
V(full)
...

}
while(1)



```

### 의문점
처음에 buffer가 큐인줄 모르고 일반 배열인줄 알았다. 그래서 만약 프로세스가 접근할때 mutex값이 아니라 mutex의 배열을 사용하여 락을 걸때 버퍼 전체를 걸지않고
접근하려는 버퍼만 걸 줄 알았다. mutex를 이용하여 하나의 프로세스가 접근할때 버퍼 전체를 락을 건다는 건 buffer가 큐이고 순차적으로 하나 하나씩 데이터가 빠져나가기때문인것
같다.


## 2. Reader - Writer 문제


## 3. Dining Philosophier(밥먹는 철학자)
