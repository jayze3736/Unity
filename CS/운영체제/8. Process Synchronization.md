# Process Synchronization

## Race condition
두개의 연산장치가 공유데이터에 접근하면서 발생하는 문제이다.

### kernel mode에서 interrupt 발생시
kernel mode에서 공유 데이터 값을 읽고 변경하는 중에 인터럽트가 발생하여 인터럽트 루틴에서 그 공유 데이터를 변경하는 경우 결과적으로 인터럽트 루틴의 처리내용은 무시되고 나중에 
수행되는 kernel mode에서의 데이터 변경만 적용되어 원치않는 프로그램 처리가 발생한다.

++) 다음 순서대로 진행
+ kernel에서 Count 변수값 읽고 레지스터에 저장
+ 인터럽트 발생 및 --Count; 
+ 다시 커널로 복귀후 읽어들인 Count값을 가지고 ++Count; 
+ 이때 읽어들인 값은 인터럽트에서 변경시키기 전의 값이므로 인터럽트에서 변경한 점은 적용이 안됨 따라서 결론적으로 Count값은 1만 증가함

#### 해결방법
kernel mode에서 공유 데이터에 접근하고 있을때는 interrupt를 발생시키지 않는다.

### kernel mode에서 timer에 의한 문맥교환시
A,B 두개의 프로세스가 존재한다. A 프로세스에서 먼저 시스템 콜이 발생하여 커널모드에서 공유 데이터 변경을 하는 도중에 문맥교환이 발생했다. 이후 B 프로세스에서 동일한 공유 데이터의 값을 변경한 다음 A 프로세스로 돌아갈때 먼저 읽어들인 데이터값을 변경하기때문에 B의 값 변경은 적용되지않고 A의 값 변경만 최종적으로 적용된다.

++) 다음 순서대로 진행
+ A에서 Count 변수값 읽고 레지스터에 저장
+ B로 문맥교환
+ B에서 --Count;
+ A로 문맥교환 후 이전에 저장한 Count값을 가지고 ++Count; 
+ 이때 읽어들인 값은 B에서 변경시키기 전의 값이므로 B에서 변경한 점은 적용이 안됨 따라서 결론적으로 Count값은 1만 증가함

#### 해결방법
kernel mode에서 문맥 교환이 일어나지 않게하고 kernel mode가 끝났을때 문맥 교환을 허용한다.

### 두개의 프로세스가 하나의 공유 데이터에 접근하는 경우(Multiprocessor Race Condition)
하나의 프로세스에서 공유 데이터에 접근하는 와중에 다른 프로세스가 그 데이터에 접근해서 값을 변경하면 가장 마지막으로 값을 변경한 프로세스가 수행한 변경만 적용되어 문제가 발생한다.

#### 해결방법
그 공유데이터에 접근하고 있는 프로세스가 있을때 다른 프로세스가 접근하지 못하도록 막아야한다.(lock)

## Critical Section
공유 데이터에 접근하는 코드 부분을 의미한다. Critical Section에 들어간다는 의미는 프로세스가 공유 데이터에 접근한다는 것을 의미한다.

## 프로그램을 통한 프로세스 동기화 문제 해결 조건

### 1. Mutual Exclusion(상호 배제)
하나의 프로세스가 공유데이터에 접근하고있을때 다른 프로세스가 그 공유 데이터에 접근하지 못하도록 해야한다.

### 2. Progress(진행)
Critical Section에 들어간 프로세스가 없을때 들어갈 수 있어야한다.

### 3. Starvation
특정 프로세스가 공유 데이터에 접근하지 못하는 시간이 지나치게 긴 경우를 막아야 한다. 

## 해결 알고리즘

### Al 1

### Al 2

### Al 3(Peterson)

## lock의 종류

### Spin lock

### Sleep lock(Sleep/Wake up 방식)


## Semaphore

### Binary semaphore

### Counting semaphore

### P연산 , V연산


## Dead lock


## Monitor







