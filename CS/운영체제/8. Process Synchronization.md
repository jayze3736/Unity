Race condition
-> 공유메모리의 접근으로 인해 발생하는 문제

1. kernel에서 인터럽트가 발생했을때 -> 운영체제에게 CPU가 넘겨져있을때는 인터럽트를 실행시키지않음
2. 두개의 프로세스가 공유 메모리를 접근했을때(Shared memory 또는 커널 데이터 처럼) -> 하나의 프로세스가 kernel mode에서
문맥 교환이 일어나지 않게하고 kernel mode가 끝날때 문맥 교환을 발생시킴. 
3. 두개의 프로세서가 동일한 커널 데이터를 접근했을때 -> lock 과 unlock을 통해 해당 공유 데이터의 접근을 제어함

2번같은 경우 조금 생각해봐야할 점은 Timer interrupt가 발생했는데도 kernel mode이기때문에 CPU를 빼앗지않는다는 점에서
불공평하게 느껴질 수 있지만 운영체제의 CPU 회수가 빡빡하지않다는 점을 알아야한다.
공유 변수값을 변경할때 처음 프로세스가 해당 변수값을 읽어서 레지스터에 저장한 후 CPU를 빼앗겨서 타 프로세스에서 변수 값을 변경한 후에
다시 돌아왔을때 CPU 문맥이 처음 변수값을 읽은상태로 재시작하기때문에 타 프로세스에서 처리한 변수값 변화는 적용되지않는다.

critical section -> 공유 데이터의 접근 코드
-> 이 섹션 전 후에 어떠한 처리를 통해서 race condition을 막아줄 수 있다.
