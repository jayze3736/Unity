PC(program counter)는 메모리 주소를 가리키며 가리키고 있는 명령어를 실행함
명령어 수행 -> 인터럽트 확인 -> OS로 CPU 점유 넘김 -> 명령어 수행

인터럽트 벡터: 인터럽트의 처리 루틴 주소를 가리키고있음
3번 인터럽트 활성화 -> 커널 코드 영역의 주소 값을 참조 -> 운영체제 커널 함수를 실행

프로그램에서 오류가 발생했을때 인터럽트가 발생할 수 있다.(Trap)

동기식 I/O 와 비동기식 I/O:
동기식 I/O는 I/O 요청을 했을때 I/O 작업이 완료될때까지 CPU를 사용하지못함
비동기식 I/O는 I/O 요청을 해놓고 CPU 사용이 가능함

동기식 I/O의 두가지 방법
1. I/O 요청 후 완료될때까지 대기 -> CPU 낭비
2. I/O 요청 후 다른 프로그램에서 요청할 I/O가 있는지 확인 그 이후 I/O 큐에 줄을 세움
초기에 요청한 I/O가 완료되면 다른 프로그램에게 CPU를 넘김 -> 다시 말해서 I/O 작업이 이루어지는 동안
다른 프로그램의 I/O 요청을 줄 세운다. 따라서 1번보다는 효율적인 동기식 입출력 방법

CPU에서 직접 접근 가능한 메모리와 불가능한 메모리
가능한 메모리(Executable) -> 바이트 단위로 접근이 가능해야함 -> register, cache memory,main memory

프로그램을 실행하면 virtual memory가 생성되며 이는 가상의 주소 공간에 해당한다.
virtual memory에서 필요한 명령어만 뽑아서 메모리에 적재하여 실행
프로그램 실행 중에 현재 필요하지않은 주소 공간은 디스크에 적재

커널의 virtual memory 구조
code - data - stack
code: 효율적인 자원 관리를 위한 코드, 시스템 콜 및 인터럽트 처리 코드
data: CPU와 메모리가 사용할 자료구조, PCB
PCB는 process control block으로, 운영체제가 프로세스를 관리하기 위해 만드는 자료 구조에 해당한다.
stack: 프로세스의 커널 스택이 쌓이며, 커널 함수 실행을 요청한 프로세스의 정보가 들어있다.

라이브러리, 사용자 정의 함수가 실행될 경우에는 프로세스 내의 주소 공간에서 PC가 이동하며 프로그램이 실행되지만
System Call이 이루어질때 사용자 프로세스의 논리적인 주소 공간에서 커널의 주소 공간쪽으로 PC의 이동이
불가능하므로 실행중인 프로세스를 그만두고 커널 모드로 진입한다. 
따라서 프로그램이 실행되면 user mode와 kernel mode를 번갈아 가며 실행된다.
