# 메모리 관리
프로그램은 메모리에 적재시켜서 실행하는데 보다 많은 프로그램을 효율적으로 실행시키기 위해서는 메모리 관리가 필요하다.

## 주소
프로그램의 데이터는 물리적인 메모리 공간에 존재하며 CPU에서 프로그램의 데이터에 접근하기 위해서는 주소를 통한 접근이 필요하다.

### 논리적 주소
프로그램의 가상 주소 공간(virtual memory)에서의 데이터 주소를 의미한다. 한번 결정된 논리 주소는 바뀌지않는다는 특징이 있기때문에 CPU는 데이터에 접근하기 위해서 논리적 주소를 사용한다.
코드상에서 사용하는 변수와 함수 등 프로그램에서 사용하는 데이터는 가상의 주소값으로 변환된다.

예를 들어, 
int i = 3;
int func();
i++;
라는 코드를 짜게 되면
i와 func()은 각각 임의의 주소값 0, 300 이라는 값을 가지게 된다.


### 물리적 주소
실제 메모리의 주소 공간을 의미한다. 물리적 주소를 사용하여 프로그램을 메모리에 적재시키며 물리적 주소는 때에 따라 바뀔 수도 있다.

## 주소 바인딩
논리적 주소를 물리적 주소로 변환하는 것을 의미한다. CPU는 논리적 주소로 데이터에 접근하기때문에 논리적 주소를 물리적 주소로 변경시킬 필요가 있다. 주소 바인딩을 하는 시점에 따라 방법이 결정된다.

### 컴파일 시점(compile time binding)
컴파일 시점에 주소 바인딩이 이루어지는 경우이다. 프로그램이 R번지 물리적 주소부터 시작되는 것을 컴파일러가 알고있다면 해당 프로그램을 R번지부터 적재시킨다. 적재시킬 위치가 고정되어있기때문에 적절한 메모리 관리를 하기가 어렵다.

예를 들어, A 프로그램이 0 부터 15번지까지 쓰고 B 프로그램이 15 부터 25번지까지 쓰고 C 프로그램이 25 부터 40번지까지 쓰기로 미리 컴파일러가 알고 있는 상황에서
A프로그램, B 프로그램이 적재된 이후 A 프로그램이 종료되어 0 부터 15번지까지 빈공간이 생겼다고 했을때 C프로그램의 크기가 0~15번지 공간보다 크지 않음에도 불구하고 미리 결정된 25 부터 40번지까지를 사용해야한다. 이렇듯 미리 주소공간을 결정해버리면 비효율적으로 관리를 할 수 밖에 없다.


### 프로그램 실행시(load time binding)
프로그램 실행시 사용가능한 공간의 시작주소를 찾고 그 주소부터 프로그램을 적재시킨다. 

컴파일 시점에 비해 비교적 효율적인 메모리 관리방법이다. 프로그램을 적재시킬때 고정된 위치가 아닌 비어있는 공간을 찾고 적재시키기때문에 나름 효율적인 메모리 관리를 할 수 있다.

### 프로그램 실행중(run time binding)
프로그램 실행시 사용가능한 공간의 시작주소를 찾고 그 주소부터 프로그램을 적재시킨다. MMU라는 하드웨어를 이용하여 프로그램 실행중에 주소변환을 한다.
중기 스케줄러(mid term scheduler)에 의해 프로그램이 swap out 당하고 다시 swap in 될때 원래 가지고 있던 물리적 주소와는 다른 새로운 물리적 주소를 할당 받을 수 있다.
따라서 run time binding 방법은 swapping을 사용하는 시스템에서 적합한 주소 바인딩이다.

## - MMU(Memory Management Unit) -
논리적 주소를 물리적 주소로 변환해주는 장치이다. ***Base Register*** 와 ***Limit Register***가 존재한다.

### Base Register
사용가능한 물리적 주소의 시작주소를 제공한다.

### Limit Register
프로그램에서 접근가능한 논리적 주소의 범위를 제공한다.

### 주소 변환
예를 들어, base 레지스터값이 14000이고 limit 레지스터값이 3000일때 논리적 주소 346번지는 물리적 주소 14000 + 346 = 14346번지로 변환된다. 프로그램은 14000번지부터 17000번지까지
접근이 가능하며 만약 변환하려는 논리적 주소가 3000을 넘어가는 경우 보안상의 문제로 주소 변환은 이루어지지않는다.

## 사용자 영역 할당 방법
메모리에 사용자 프로그램이 적재되는 영역은 사용자 영역, OS 프로그램이 적재되는 영역은 OS 상주 영역이라고 부른다. 사용자 영역에 프로그램을 적재시킬때의 방법은 프로그램을 통째로(연속적) 또는 분할하여(불연속적) 적재시키는 방법으로 분류된다.

### 연속적 할당 방법(Contiguous allocation)
프로그램을 통째로 적재시키는 방법

#### 고정 분할 방법
메모리를 미리 분할시키고 프로그램을 순차적으로 적재시킨다.(이때 분할 크기는 모두 똑같지않다.) 외부조각과 내부조각이 발생할 수 있다.

#### 가변 분할 방법
메모리를 분할하되 실행시킬 프로그램의 크기에 맞춰 분할한다. 외부조각이 발생할 수 있다.
예를 들어, 가변 분할 방법으로 프로그램을 적재시킨 후 어느 한 프로그램이 종료되어 홀(Hole)이 발생하는 경우 그 홀에 새로운 프로그램을 적재시킬 수 있는데, 이때 프로그램의 크기가
홀과 맞아떨어지지 않을경우 남는 공간이 생긴는데, 이 공간을 외부조각이라고 한다.

#### 외부 조각 / 내부 조각(Internal / External fragmentation)
내부 조각: 프로그램의 크기 < (분할한) 공간의 크기일때 발생하는 여유 공간을 의미한다.
외부 조각: 프로그램의 크기 > (분할한) 공간의 크기일때 적재하지못하여 사용되지못한 빈 공간을 의미한다.

#### 홀
프로그램이 종료되어 반납하는 공간을 의미한다. 외부조각으로 분류한다.

### 불연속적 할당 방법(Non-contiguous allocation)
프로그램을 단위로 분할하여 메모리 공간에 분산시켜 적재하는 방법

#### 페이징 기법(paging)
프로그램을 페이지 단위로 분할하고 메모리 공간을 프레임 단위로 분할한 다음, 각 페이지에 대응되는 프레임을 페이지 테이블에 작성한다. 그리고 페이지 테이블에 접근하여 n번째 페이지에 대응되는 프레임 번호를 알아내고 해당 프레임에서 offset만큼 떨어진 곳을 물리적 주소로 반환하는 방법이다.

#### segmentation

#### 

## 메모리 관리 관련 용어

### Dynamic Loading & Overlay
프로그램에서 자주 사용되지않는 코드(ex. 예외 처리코드)를 메모리에 적재시키는 것은 비효율적이기때문에 필요한 코드 부분만을 메모리에 적재시키도록 하는 방법
Dynamic Loading은 OS에서 지원하는 라이브러리의 지원을 받아 유저가 직접 코드를 통해 메모리 관리를 하게 하는 방법이고
Overlay는 옛날에 라이브러리가 없었을때 수작업으로 코드를 직접짜서 메모리 관리를 하는 방법을 의미한다.
Paging은 위의 개념과 달리 OS에서 자동으로 메모리 관리를 하기때문에 Paging과 Dynamic Loading/Overlay는 메모리 관리를 자동/수동으로 하느냐의 차이가 있고
Dynamic Loading과 Overlay의 차이는 라이브러리 지원 유무이다.

### Dynamic Linking(Shared Library)
프로그램에서 라이브러리를 사용할때 해당 라이브러리 코드를 그대로 프로그램과 함께 메모리에 적재시켜야 한다. 그러나 극단적으로 100만개의 프로그램을 적재시킬때 해당 라이브러리 코드도
100만개만큼 적재시켜야하기때문에 비효율적으로 코드가 메모리에 적재가 된다. 따라서 라이브러리 코드를 한 카피만 메모리에 올리고 프로젝트 파일내에 stub 파일을 사용하여 필요한 라이브러리 데이터를 찾도록 한다. DLL(Dynamic Link Library) 파일이 stub 파일에 해당한다.

### Swapping
중기 스케쥴러에 의해 메모리에 적재된 프로그램이 디스크로 추방되는 것을 swap out, 디스크에서 다시 메모리로 불러오는 것을 swap in이라고 한다. 우선순위(priority)가 낮은 프로그램을 우선으로 추방한다.


