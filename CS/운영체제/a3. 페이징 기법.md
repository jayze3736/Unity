# 페이징 기법(Paging)
논리적 주소 공간을 페이지 단위로 분할하고 페이지를 메모리에 분산시켜 적재시키는 방법이다.   
프로그램의 논리적 주소 공간(virtual memory)을 전부 페이지 단위로 나누고 메모리의 물리적 주소 공간을 프레임 단위로 나눈다. 이때 페이지와 프레임의 크기 값은 동일해야한다.   
페이지 번호와 오프셋 d 값을 논리적 주소로 하여금 페이지 테이블을 통해 주소 변환을 거치고 물리적 주소를 반환 받는다. 오프셋 d는 n번째 페이지 또는 프레임의 시작주소로부터 얼마만큼
떨어져있는지를 나타내는 값이다.   


## 페이지 테이블
1. 분할한 페이지가 어느 프레임위치로 적재되야하는지를 작성해놓은 테이블을 페이지 테이블이라고한다.   
2. 페이지 테이블은 배열로 구현되며 배열의 인덱스로 페이지 번호를 나타내고 그 인덱스에 위치하는 값을 프레임 번호로 지정한다. 예를 들어, n번째 배열의 값이 k라면 프로그램의 n번째 페이지가 k번째 프레임 위치에 적재된다는 것을 의미한다.   
3. 페이지 테이블의 크기가 비교적 크기때문에 메모리에 적재한다. 따라서 주소 변환을 할때는 메모리 접근을 두번해야한다는 점이 있지만 TLB라는 캐쉬 메모리를 통해 주소 변환 속도를 향상시킬 수 있다.     
4. 사용되지않는 논리적 주소공간까지 포함하여 페이징하므로 페이지 테이블 또한 빈공간에 대한 페이지 엔트리를 가지고 있어야한다.  
5. 주의해야할 점은 프로그램에서 분할된 페이지와 페이지 테이블이 헷갈릴만하다는 것이다.   

### PTBR(Page Table Base Register)
CPU에서 페이지 테이블에 접근할때 사용하는 레지스터, 프로그램마다 페이지 테이블이 존재하므로 메모리에 여러개의 페이지 테이블이 적재된다. 따라서 CPU에서 특정 페이지 테이블로 접근하기 위해서 PTBR을 사용한다.  

## 주소 변환
1. 페이지는 논리적 주소를 포함하고 있고 프레임은 물리적 주소를 포함하고 있다. 따라서 페이지에서 프레임으로 변환하는 것은 논리적 주소를 물리적 주소로 변환하는 것과 동일하다.    
2. 먼저 주소 변환을할때 필요한 것은 페이지 번호와 offset이다. 페이지 번호 p와 offset d가 주어졌을때 페이지 테이블에 접근하여 p번째 배열의 값을 알아낸다.     
3. 그 이후 그 값에 해당하는 프레임에 접근한 후 프레임의 시작 주소로부터 offset만큼 떨어진 주소공간을 물리적 주소로 반환한다. offset d는 상대적인 위치이기때문에 주소 변환을할때 변하지 않는다.  

![제목 없음](https://user-images.githubusercontent.com/79313194/168428769-44522ecd-e691-4776-896c-24e2fabd2513.png)

## 문제점

### 시간 문제 - 주소 변환
페이지 테이블은 메모리에 적재시키기때문에 1번 주소 변환을 하려면 페이지 테이블에 접근하는데 1번, 페이지 테이블로부터 얻은 프레임 위치에 접근하는데 1번 총 두번의 메모리 접근이 필요하다. CPU가 메모리 접근하는데 걸리는 시간이 두배로 걸리기때문에 속도적인 측면에서 성능이 떨어진다. 따라서 TLB라는 캐쉬 메모리를 사용한다.   


### 공간 문제 - 사용되지않는 공간의 페이징
프로그램에서 사용되지않는 공간까지 페이지 테이블의 엔트리로 작성해야한다. 페이지 테이블은 인덱스값으로 프로그램의 논리 주소 공간의 시작점에서 몇번째 페이지인지를 알아내기때문에
비어있는 공간을 빼고 페이지 테이블을 작성할 수 없다.   

헷갈릴만한 점이 있는데, 프로그램에서 빈공간을 빼고 페이지 번호를 매기면 안되나 싶기도하다. 예를 들면 1 2 3 4 5 페이지가 있고 4번 페이지가 비어있다면 1 2 3 4 5 번 페이지를 1 2 3 () 4 번 페이지로 구성하고 페이지 테이블에 엔트리를 작성하면 되지않을까 싶다.    
그러나 페이지 테이블의 인덱스는 프로그램에서 매기는 페이지 번호와는 무관하기때문에 페이지 번호를 논리주소상에서 다르게 해도 접근하는 위치는 변하지않는다.

따라서 페이지 테이블 엔트리를 작성할때는 사용되지않는 페이지까지 작성해야하며 사용되지 않는 페이지 테이블 엔트리가 공간 문제를 발생시킨다.

### 공간 문제 - 페이지 테이블의 크기
32 bit로 물리적 주소 공간을 표현할 수 있다고 가정하자. 0 부터 2^32 - 1까지 주소 표현이 가능하며 메모리의 단위가 byte = B 이므로 물리적 메모리는 4GB(2^32 B)의 크기를 가진다.   
만약 12bit로 offset을 표현하고 20bit로 페이지 번호를 매긴다면 총 2^20개의 페이지와 페이지 테이블의 엔트리가 생긴다.    
페이지 엔트리 한개당 보통 4B이므로 페이지 테이블의 크기 = 2^20개 * 4B = 4 * 2^20 B = 4MB의 크기를 가진다.    

프로그램마다 페이지 테이블이 존재해야하므로 4MB 크기의 페이지 테이블이 여러개 적재되면 메모리에서 비용(공간)이 꽤 크기때문에 부담이 된다.   

### 공간 문제 - 내부 조각
논리적 주소 공간을 균일한 크기의 페이지로 분할하면 프로그램의 크기가 페이지 단위로 나누어 떨어지지않는 경우가 발생할 수 있다. 이 경우 페이지내에서 사용되지않는 공간이 생기는데 이때 발생하는 내부 조각 문제가 존재한다. (근데 어쩔 수 없음)  

## 해결 방법
### 시간 문제 - TLB
TLB(Translation Lookaside Buffer)는 캐쉬 메모리로, 페이지 테이블의 엔트리의 일부를 캐쉬해놓는다. 주소 변환을 할때 페이지 테이블에 접근하지않고 TLB에 먼저 접근하여 엔트리를 확인하여 주소 변환을 하는데 걸리는 시간을 줄일 수 있다.   

![제목 없음](https://user-images.githubusercontent.com/79313194/168457550-32bdcdbb-81b3-4a4b-92ab-9838904559ab.png)


### TLB 특징
1. 페이지 테이블의 엔트리 일부를 저장하기때문에 page 번호와 frame 번호의 tuple을 가지고 있어야한다.   
2. page - frame 튜플을 검색할때 수평적으로 모든 엔트리를 한번에 검색한다.   
3. hit ratio는 검색하고자하는 page - frame 튜플을 TLB에서 찾을 횟수를 의미한다. 예를 들어, 80%의 hit ratio라는 의미는 TLB 테이블에 캐쉬된 튜플중 80%가 찾고자하는 페이지를 보유하고 있다는 의미이다.   
4. context switching(문맥 교환)이 발생할때 TLB를 flush(모두 삭제)해야한다.   

### 주소 변환 시간(EAT)
메모리에 접근하는 시간을 1이라고 하고 hit ratio = a, TLB 접근시간을 e라고 할때  

TLB를 이용한 평균적인 주소 변환 시간 = a * (e + 1) + (1 - a) * (e + 2) = 2 + e - a

### 공간 문제 - 다단계 페이징
다단계 페이징을 사용하면 적재시킬 페이지 테이블의 크기를 줄이고 사용되지않는 공간을 페이지 테이블의 엔트리로 작성할 필요가 없어진다.   


# 이단계 페이징(Two-level paging)
## 방법
- 페이징된 페이지 테이블을 다시 페이징하는 방법이다. 페이지 테이블을 다시 페이징하여 만든 페이지 테이블을 바깥쪽 페이지 테이블(outer table)이라고 한다.   
바깥쪽 페이지 테이블의 엔트리 하나가 페이지 테이블이므로 이것을 안쪽 페이지 테이블(inner page table)이라고 한다. 메모리에 적재시키는 페이지 테이블은 안쪽 페이지 테이블이다.   

- 프로그램에서 사용되지않는 공간은 바깥쪽 페이지 테이블에서 NULL의 엔트리 값을 가지며 NULL에 페이징 되지않으므로 사용되지않는 공간에 대한 페이지 엔트리를 줄일 수 있어 공간상 이득을 얻는다.  

- 메모리 주소 접근을 할때 바깥쪽 페이지 번호 p1, 안쪽 페이지 번호 p2, offset d로 접근한다.

- 32 bit 주소 체계를 예로 들면 먼저 12bit로 offset 값을 표현할때 안쪽 페이지의 테이블 크기가 하나당 4KB이고 엔트리당 4B의 크기를 가지면 1K개의 안쪽 페이지 번호 표현이 가능해야한다. 따라서 p2는 1K = 2^10개의 주소 표현이 가능해야하고 이는 10bit로 p2를 표현해야한다는 것을 의미한다.   
나머지 32bit - 22bit = 10bit로 바깥쪽 페이지 번호를 표현해야하므로 2^10개의 바깥쪽 페이지 테이블이 생긴다.  
내부 페이지 엔트리 1개당 offset 표현수 = 2^12개  
내부 페이지 테이블 1개당 페이지 엔트리 수 = 내부 페이지 번호 가짓수 = 2^10개  
외부 페이지 테이블 엔트리 수 = 내부 페이지 테이블 개수 = 2^10개   
따라서 2^10 * 2^10 * 2^12 = 2^32 이므로 32bit의 주소 공간을 표현할 수 있다.

- 2^10개의 바깥쪽 페이지 테이블 엔트리 그리고 엔트리당 4B의 크기를 가지기때문에 바깥쪽 페이지 테이블의 크기는 2^10 * 4B = 4KB 이고 안쪽 페이지 테이블 또한 4KB이다.   
메모리에 바깥쪽 페이지 테이블은 반드시 적재시켜야하며 안쪽 페이지 테이블은 2^10(1024)개중에서 선택적으로 적재시킨다.   
메모리에 적재되는 테이블은 총 두개이므로 한번 주소변환을 하는데 두번 메모리에 접근을 해야한다.

## 개요
1.
![제목 없음](https://user-images.githubusercontent.com/79313194/168459649-4ee3c6aa-3103-4466-ab01-c128cb834ff3.png)

2.
![제목 없음](https://user-images.githubusercontent.com/79313194/168459675-31b76aec-af62-47f4-8d8f-b02e20c90a11.png)

## 장점과 단점
장점: 이단계 페이징은 쉽게 얘기하면 페이지 테이블을 또 쪼개서 여러개의 테이블 조각을 만들면 올려야하는 페이지 테이블의 크기가 줄어들고 사용되지않는 영역을 배제하여 메모리를 조금 더 효율적으로 사용할 수 있다는 장점이 있다.    
단점: 안쪽 페이지 테이블, 바깥쪽 페이지 테이블 총 두번 테이블에 접근해야하기때문에 주소 변환 시간이 늘어난다.    

### 다단계 페이징
여러번 페이지를 쪼개고 쪼개는 다단계 페이징의 경우 사용 공간을 줄일 수 있지만 주소 변환 시간이 늘어난다.   

# Invalid/Valid 페이지 테이블
페이지 테이블을 작성할때 엔트리에 Invalid/Valid bit 그리고 Protection bit을 추가하여 해당 엔트리가 유효한지 표시한다. v이면 valid, i이면 invalid 하다는 뜻이다.   
- v: 해당 엔트리의 페이지가 유효하다는 뜻이다.   
- i: 첫번째 경우는 해당 페이지가 프로그램에서 유효하지않다는 뜻이고 두번째 경우는 현재 해당 번호의 페이지가 현재 swap out 되었다는 뜻이다.    
- protection bit: 해당 페이지가 Read/Write/Read-Only인지를 표시하는 비트   

![제목 없음](https://user-images.githubusercontent.com/79313194/168478736-06789d73-f5c7-47c1-8369-c7e8f39a5bf8.png)



### protection bit를 사용하는 이유?
논리적 주소공간이 페이징될때 data - code - stack 영역으로 나뉘는데, code 영역의 경우 명령어를 저장하고 있고 프로그램이 실행되는 동안에 해당 명령어가 바뀌는 일이 있으면 원치않는 처리가 발생할 수 있기때문에 code 영역을 담고 있는 페이지는 접근 권한을 read-only로 설정해야한다.     
반면 data, stack 영역은 프로그램 실행중에 수정될 일이 발생하므로 해당 영역의 페이지는 read, write 권한을 모두 줘야한다.     
이처럼 virtual memory에서 영역별로 접근 권한을 달리해야하기때문에 페이지 엔트리에 protection bit을 추가한다.     


# Inverted 페이지 테이블
원래 페이징 기법은 페이지 테이블에서 인덱스가 페이지 번호에 해당하고 배열 값이 프레임 번호에 해당한다.   
이와 반대로 인덱스를 프레임 번호로 지정하고 해당 위치의 엔트리 값이 페이지, 프로세스 번호인 페이지 테이블을 Inverted 페이지 테이블이라고 한다.   
inverted page table의 엔트리는 pid, page 값을 보유하고 있으며 테이블의 인덱스가 프레임 번호에 해당한다.  

각 프로세스의 논리 주소(페이지) 마다 엔트리를 생성하는 대신 유일한 물리 메모리의 물리 주소(프레임)마다 엔트리를 생성하기때문에 프로세스마다 페이지 테이블을 생성할 필요가 없고 하나의 페이지 테이블로 주소 변환이 가능하다.   

역 페이지 테이블에서 인덱스는 유일하기때문에 n번째 프레임에 위치하는 페이지는 오로지 하나만 존재하게 된다. 즉, 하나의 프레임에 하나의 프로세스의 페이지만 적재가 가능하다.(다른 프로세스에서 이미 적재중인 프레임에 접근해야할 경우 역 페이지 테이블의 해당 인덱스의 엔트리값이 접근하려는 프로세스 id와 페이지로 바뀐다.)   

예를 들어, pid = 7000, page = 5의 논리 주소값이 주어지면 해당 테이블을 탐색하고 n번째 엔트리인지를 알아내면 해당 인덱스 n의 값을 프레임값으로 반환한다.   

![제목 없음](https://user-images.githubusercontent.com/79313194/168609012-d5c81266-e94d-4eee-a59c-9e7b70fd09c6.png)

### if?
그냥 문득 생각이 든건데, 만약 기본 페이지 테이블 접근방식에서 테이블 엔트리에 Pid값을 추가해서 p, pid -> f값을 얻어내는 방법이 있으면 각 프로세스마다 페이지를 생성할 
필요가 없지않을까 생각이 들겠지만 여기서 잘못된 부분이 존재한다. 먼저 테이블 엔트리에서 index인 p값으로 엔트리에 접근하고 테이블에서 각 인덱스마다 엔트리가 하나밖에 존재할 수 밖에 없기때문에 특정 프로세스가 페이지 테이블 엔트리를 독점하는 경우가 발생하므로 이러한 경우는 발생하면 안된다.

## 역 페이지 테이블 장점 & 단점
장점: 프로세스 마다 페이지 테이블을 생성할 필요가 없다.   
단점: 배열의 인덱스가 페이지 번호가 아닌 프레임 번호를 나타내고 PTBR은 p(페이지 번호)와 pid(프로세스 번호)로 접근하기때문에 엔트리 탐색 시간이 증가한다.   

단점 해결: associative register를 사용하여 TLB와 동일하게 수평적으로 엔트리를 검색할 수 있게 하여 속도를 높인다.    


# Shared Code
유사한 프로세스에서 사용하는 코드 공간의 데이터가 일치할때 메모리에 코드 영역에 해당하는 페이지를 프로세스마다 적재시키지않고 한 카피만 적재시키는 방법이다.   
이러한 공유 가능 코드를 Re-entrant code(재진입 코드)라고 하며 이 코드는 두가지 조건하에 메모리에서 하나의 카피(페이지)로 여러 프로세스가 공유하여 사용가능하다.    

1. 공유하는 코드 페이지가 Read-only 여야한다. (한 프로세스가 공유 페이지를 사용하는 도중에 다른 프로세스가 그 페이지를 사용할 경우 문제가 발생 가능하다.)   
2. 코드 영역의 논리적 주소가 동일해야한다. (그렇지 않으면 공유하고 있는 코드 페이지에 접근에 실패하는 프로세스가 존재할 수 있기 떄문이다.)  







