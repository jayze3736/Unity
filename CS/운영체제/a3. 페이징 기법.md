# 페이징 기법(Paging)
프로그램을 페이지 단위로 분할하고 페이지 단위로 메모리에 분산시켜 적재시키는 방법이다.
프로그램의 논리적 주소 공간(virtual memory)를 페이지 단위로 나누고 메모리의 물리적 주소 공간을 프레임 단위로 나눈다. 이때 페이지와 프레임의 크기 값은 동일해야한다.
페이지 번호와 오프셋 d 값을 논리적 주소로 하여금 페이지 테이블을 통해 주소 변환을 거치고 물리적 주소를 반환 받는다. 오프셋 d는 n번째 페이지 또는 프레임의 시작주소로부터 얼마만큼
떨어져있는지를 나타내는 값이다.

## 페이지 테이블
분할한 페이지가 어느 프레임위치로 적재되야하는지를 작성해놓은 테이블을 페이지 테이블이라고한다.
페이지 테이블은 배열로 구현되며 배열의 인덱스로 페이지 번호를 나타내고 그 인덱스에 위치하는 값을 프레임 번호로 지정한다. 예를 들어, n번째 배열의 값이 k라면 프로그램의 n번째 페이지가
k번째 프레임 위치에 적재된다는 것을 의미한다.
페이지 테이블의 크기가 비교적 크기때문에 메모리에 적재한다. 따라서 주소 변환을 할때는 메모리 접근을 두번해야한다는 점이 있지만 TLB라는 캐쉬 메모리를 통해 주소 변환 속도를 향상시킬 수 있다.  
주의해야할 점은 프로그램에서 분할된 페이지와 페이지 테이블이 헷갈릴만하다는 것이다.

## 주소 변환
페이지는 논리적 주소를 포함하고 있고 프레임은 물리적 주소를 포함하고 있다. 따라서 페이지에서 프레임으로 변환하는 것은 논리적 주소를 물리적 주소로 변환하는 것과 동일하다.  
먼저 주소 변환을할때 필요하는 것은 페이지 번호와 offset이다. 페이지 번호 p와 offset d가 주어졌을때 페이지 테이블에 접근하여 p번째 배열의 값을 알아낸다. 그 이후 그 값에 해당하는
프레임에 접근한 후 프레임의 시작 주소로부터 offset만큼 떨어진 주소공간을 물리적 주소로 반환한다. offset d는 상대적인 위치이기때문에 주소 변환을할때 변하지 않는다.

![제목 없음](https://user-images.githubusercontent.com/79313194/168428769-44522ecd-e691-4776-896c-24e2fabd2513.png)

## 문제점
32 bit로 물리적 주소 공간을 표현할 수 있다고 가정하자. 0 부터 2^32 - 1까지 주소 표현이 가능하며 메모리의 단위가 byte = B 이므로 물리적 메모리는 4GB(2^32 B)의 크기를 가진다.
만약 12bit로 offset을 표현하고 20bit로 페이지 번호를 매긴다면 총 2^20개의 페이지와 페이지 테이블의 엔트리가 생긴다. 페이지 엔트리 한개당 보통 4B이므로 페이지 테이블의 크기 = 2^20개 * 4B = 4 * 2^20 B = 4MB의 크기를 가진다.

### 사용되지않는 공간의 페이징
프로그램에서 사용되지않는 공간까지 페이지 테이블의 엔트리로 작성해야한다. 

### 페이지 테이블의 크기
4MB 크기의 페이지 테이블을 프로그램 별로 적재시키면 메모리에서 비용(공간)이 꽤 크기때문에 부담이 된다.

### 해결 방법
다단계 페이징을 사용하면 적재시킬 페이지 테이블의 크기를 줄이고 사용되지않는 공간을 페이지 테이블의 엔트리로 작성할 필요가 없어진다.


## 이단계 페이징



## 다단계 페이징

