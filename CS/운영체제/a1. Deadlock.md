# Deadlock
두개 이상의 프로세스가 서로에게 필요한 자원을 보유한 상태에서 상대방이 가지고 있는 자원을 요청할때 발생하는 문제이다. 

## Deadlock 발생 조건

### 1. Mutual Exclusion(상호배제)
데드락은 상호배제를 전제로 일어난다. 만약 하나의 자원에 여러개의 프로세스가 접근이 가능하다면 데드락은 발생하지않는다.(보유라는 개념이 사라지기때문)

### 2. Hold and wait(보유 대기)
자원을 보유한 채로 다른 프로세스의 자원을 요청하는 경우 데드락이 발생한다.

### 3. No preemption(비선점)
자원을 빼앗지않고 자진 반납할때까지 기다리면 특정 프로세스는 자원을 보유한채로 대기할 수 있기때문에 데드락이 발생한다.

### 4. Circular wait(순환대기)


## Deadlock 처리 방법
1. Deadlock prevention(예방)
2. Deadlock avoidance(회피)
3. Deadlock detect and recovery(발견 및 수복)
4. Deadlock Ignorance(무시)

## Deadlock prevention(예방)
Deadlock 발생 조건을 차단하여 데드락이 발생할 여지를 없애는 방법

### 1. Mutual Exclusion(상호배제)
프로세스가 자원에 대해서 상호배제 방식으로 접근한다는 것을 전제로 Deadlock을 논하고있기때문에 이는 예방할 수 없는 조건이다.(상호배제가 무조건 만족되어야한다.)

### 2. Hold and wait(보유 대기)
다른 프로세스가 보유하고 있는 자원을 요청할때 자신이 들고있는 프로세스를 모두 반납한다. 반납한 프로세스를 다른 프로세스가 사용한 후 종료되어 원래 들고있던 자원과 필요로 했던
자원을 얻고 다시 시작한다.

### 3. No preemption(비선점)
선점을 가능케하여 다른 프로세스의 자원을 필요로 할 경우 빼앗도록 한다.

### 4. Circular wait(순환대기)
출처: https://kukuta.tistory.com/281

![1](https://user-images.githubusercontent.com/79313194/166873058-4dfb212d-25b0-4d65-b38f-e00eb649532a.png)

프로세스들이 꼬리에 꼬리를 물고 서로 가진 자원을 요청하는 경우를 의미한다.

출처: https://kukuta.tistory.com/281
![2](https://user-images.githubusercontent.com/79313194/166873165-c475fc4a-4690-4ba0-808a-465525b031b9.png)

R2의 두개의 점을 출발점으로 그래프의 화살표를 따라가다보면 두개의 고리가 만들어 진다.   
첫번째 고리: R2 -> P1 -> R1 -> P2 -> R3 -> P3 -> R2    
두번째 고리: R2 -> P2 -> R3 -> P3 -> R2       
R2 box의 두개의 자원으로부터 고리가 모두 만들어지므로 이런 경우에는 데드락이 발생한다.     



## Deadlock avoidance(회피)
데드락이 발생할 여지가 있는 프로세스에게는 자원을 할당하지않는다. ***이때 각 프로세스가 최대로 필요로하는 자원의 개수를 미리 선언하고 알고리즘을 사용한다.***

### 회피 알고리즘
1. Resource Allocation Graph Algorithm: 프로세스당 하나의 자원을 요청할 경우 사용하는 알고리즘
2. Banker's Algorithm: 프로세스당 여러개의 자원을 요청할 경우 사용하는 알고리즘

### Resource Allocation Graph Algorithm
#### 방법
1. 자원 박스(R)과 프로세스 노드(P)가 존재할 때 현재 자원을 할당 상황을 화살표로 표시한다.
2. P -> R로 나가는 화살표는 P가 R에게 자원을 요청했다는 의미이고 R -> P로 나가는 화살표는 R이 P에게 자원을 할당했다는 의미이다.
3. 추가로, P -> R 방향의 화살표중 실선 화살표인 경우는 P가 R에게 자원을 요청할 수도 있음을 의미한다.
4. P와 R의 관계를 그래프로 표현한 후, 어떤 프로세스가 자원을 요청했을때 실선 화살표를 포함하여 사이클(또는 고리)이 만들어질 경우 데드락이 발생할 수 있다고 판단하고 자원 할당 요청을 거부한다. 

#### - 예시 -

![제목 없음](https://user-images.githubusercontent.com/79313194/166913539-7d8ceb9d-107f-4f75-a2f1-45ad09b50801.png)

다음과 같은 자원할당상황은 사이클이 없기때문에 데드락 상황이 아니다. 그러나 P2가 R1에게 자원을 요청을 할 경우 데드락이 발생할 수 있으므로 요청한다면 자원을 할당해주지 않는다.




### Banker's Algorithm
#### - 방법 -
1. 먼저 가용자원(현재 사용가능한 자원), 각 프로세스의 자원 할당 상태, 각 프로세스의 요청할 수 있는 최대 자원 수를 나열한다.
2. 어떤 프로세스가 자원을 요청했을때 그 프로세스의 최대 요청 자원 수가 가용자원보다 많을 경우 자원을 할당하지않는다.
3. 프로세스의 최대 요청 자원 수가 가용자원보다 적을 경우 자원을 할당하고, 자원을 받은 프로세스가 종료되어 보유하고있는 자원을 반납한 후 가용자원의 수가 최대 요청 자원 수보다 많은 프로세스를 찾는다.
4. 찾은 프로세스에 대해서 자원을 할당하고 또 다시 가용자원수가 최대 요청 자원 수보다 많은 프로세스를 찾는 과정을 반복한다.
5. 이 알고리즘으로 자원을 할당하는 순서가 생기는데 이를 safe sequence라고 한다. safe sequence가 존재할 경우 시스템이 안전하며 데드락이 발생하지않는다. 그러나 safe sequence가 끊길때는 unsafe하며 데드락이 발생할 수 있다.

#### - 예시 -
##### 표현
Allocation = A<A, B, C> (현재 프로세스에 할당한 자원 수)    
Max = M<A, B, C> (현재 프로세스의 자원 할당 max 값)     
Available = Avail<A, B, C> (현재 가용 자원의 개수)     
Need = N<A, B, C> (Max - Allocation 값, 즉 현재 최대로 요구할 수 있는 자원의 수)    
Given = G<A, B, C> (처음 주어진 자원의 수)    
위의 표현들은 내가 정리하려고 사용하는 표현들이다, 실제로는 사용 X    

##### 상황
P0, P1, P2, P3, P4 다섯개의 프로세스가 존재하고 자원할당 상황이 다음과 같다.    
G<10, 5, 7>    
Avail<3, 3, 2>   

P0: A<0, 1, 0> M<7, 5, 3> N<7, 4, 3>   
P1: A<2, 0, 0> M<3, 2, 2> N<1, 2, 2>   
P2: A<3, 0, 2> M<9, 0, 2> N<6, 0, 0>   
P3: A<2, 1, 1> M<2, 2, 2> N<0, 1, 1>   
P4: A<0, 0, 2> M<4, 3, 3> N<4, 3, 1>   

##### 분석
P0가 최대로 요구할 수 있는 자원의 수인 N<7, 4, 3>은 Avail<3, 3, 2>보다 크므로 현재 P0에게 자원은 할당 불가능하다.

P1가 최대로 요구할 수 있는 자원의 수인 N<1, 2, 2>은 Avail<3, 3, 2>보다 적으므로 현재 P1에게 자원은 할당 가능하다.  

P2가 최대로 요구할 수 있는 자원의 수인 N<6, 0, 0>은 Avail<3, 3, 2>보다 크므로 현재 P2에게 자원은 할당 불가능하다.  

P3가 최대로 요구할 수 있는 자원의 수인 N<0, 1, 1>은 Avail<3, 3, 2>보다 적으므로 현재 P3에게 자원은 할당 가능하다.  

P4가 최대로 요구할 수 있는 자원의 수인 N<4, 3, 1>은 Avail<3, 3, 2>보다 크므로 현재 P4에게 자원은 할당 불가능하다.  


P1 또는 P3에게 자원을 할당가능하다.   
P1에게 자원을 할당하는 경우 반납할 자원 A<2, 0, 0>와 기존에 갖고 있던 가용자원 Avail<3, 3, 2>을 합치면 <5, 3, 2>가 된다. => <P1, 


합친 자원을 P3에게 줄 수 있고 A<2, 1, 1> + <5, 3, 2> = <7, 4, 3>가 된다. => <P1, P3  

합친 자원을 P0에게 줄 수 있고 A<0, 1, 0> + <7, 4, 3> = <7, 5, 3>이 된다. => <P1, P3, P0  

합친 자원을 P2에게 줄 수 있고 A<3, 0, 2> + <7, 5, 3> = <10, 5, 5>이 된다. => <P1, P3, P0, P2  

합친 자원을 P4에게 줄 수 있고 A<0, 0, 2> + <10, 5, 5> = <10, 5, 7>이 된다. => <P1, P3, P0, P2, P4>  

따라서 다섯개 프로세스에 대한 safe sequence <P1, P3, P0, P2, P4>이 완성되므로 현재 시스템은 safe하다.   

만약 safe sequence를 완성시키는 도중 합친 자원으로도 최대로 요구할 수 있는 자원 수를 맞출 프로세스가 존재하지않으면 전 과정으로 돌아가서 다른 프로세스에게 자원을 할당 시켜봐야한다.   
병합한 자원으로도 도저히 safe sequence를 만들 수 없을때는 시스템이 unsafe하다고 판단하며 이 경우에는 deadlock이 발생할 수 있다.

### 자원할당 그래프를 Banker's 알고리즘으로 분석하는 법
Banker's 알고리즘을 이용하여 자원할당 그래프에서 시스템이 safe/unsafe한지 알 수 있다. 즉, 데드락이 발생할 수 있는지 없는지 알아낼 수 있다.

![1](https://user-images.githubusercontent.com/79313194/166914341-c7ac8b7e-1d43-417e-a4c8-7f5691271cc9.png)

출처: https://www.gatevidyalay.com/resource-allocation-graph-deadlock-detection/


R = <R1, R2, R3>  
S = safe squence  
Avail<0,0,1>   

P0: A<1,0,1> N<0,1,1>   
P1: A<1,1,0> N<1,0,0>   
P2: A<0,1,0> N<0,0,1>   
P3: A<0,0,1> N<0,2,0>   

P2에 대하여 Avail<0,0,1> = N<0,0,1> 이므로 P2에게 자원할당 가능 자원 병합시 R = <0,1,1>, S = <P2  
P0에 대하여 Avail<0,1,1> = N<0,1,1> 이므로 P0에게 자원할당 가능 자원 병합시 R = <1,1,2>, S = <P2, P0  
P1에 대하여 Avail<1,1,2> > N<1,0,0> 이므로 P1에게 자원할당 가능 자원 병합시 R = <2,2,2>, S = <P2, P0, P1  
P3에 대하여 Avail<2,2,2> > N<0,2,0> 이므로 P3에게 자원할당 가능 자원 병합시 R = <2,2,3>, S = <P2, P0, P1, P3>  
따라서 시스템은 safe하며 데드락이 발생하지않는다.




## Deadlock detect and recovery(발견 및 수복)
### Detect
그래프를 만들고 

### Recovery
1. kill deadlocked process: 데드락이 발생한 프로세스를 강제 종료시킨다.
2. kill one process and see deadlock happens: 무작위로 프로세스를 하나 종료시키고 데드락이 없어지는지 확인한다. 없어질때까지 과정을 반복한다.

## Deadlock Ignorance(무시)
위와 같은 데드락 처리 방법들은 오버헤드가 크기때문에 대부분의 운영체제는 위의 방법을 채택하기보다 데드락이 발생하면 사용자가 처리하도록 하는 방식을 채택하고 있다.



